# План разработки Dead Code Hunter

## 1. Общая структура проекта
1. **Директории проекта:**
   - `src/` — исходный код утилиты.
   - `include/` — заголовочные файлы.
   - `tests/` — тесты для проверки функциональности.
   - `docs/` — документация.
   - `build/` — директория для сборки.

2. **Основные модули:**
   - `main.c`: точка входа в программу.
   - `file_scanner.c/h`: модуль для рекурсивного обхода директорий.
   - `parser.c/h`: модуль для разбора исходного кода.
   - `analyzer.c/h`: модуль для анализа кода и поиска зависимостей.
   - `cleaner.c/h`: модуль для удаления неиспользуемого кода.
   - `reporter.c/h`: модуль для генерации отчётов.

3. **Сторонние библиотеки:**
   - `libclang` для анализа C/C++ кода.
   - Опционально: парсеры для других языков.

---

## 2. Принцип работы утилиты

### Шаг 1: Чтение входных данных
- Парсинг аргументов командной строки с помощью POSIX API (`getopt`).
- Проверка доступности указанного пути (`stat`).
- Определение языка программирования (если явно не указано, то по расширению файлов).

### Шаг 2: Рекурсивное сканирование файлов
- Использование системных вызовов (`opendir`, `readdir`) для обхода файлов и директорий.
- Фильтрация файлов по расширению.
- Формирование списка файлов для анализа.

### Шаг 3: Разбор исходного кода
- Открытие каждого файла для чтения.
- Использование парсера для построения AST (Abstract Syntax Tree).
- Сбор информации о:
  - Импортах.
  - Определениях функций, классов, методов, переменных.
  - Местах использования этих элементов.

### Шаг 4: Анализ зависимостей
- Построение графа зависимостей:
  - Узлы графа — элементы кода (импорты, функции и т.д.).
  - Рёбра графа — вызовы или ссылки на эти элементы.
- Рекурсивный обход графа для поиска неиспользуемых элементов.

### Шаг 5: Удаление неиспользуемого кода
- Открытие файла для редактирования.
- Нахождение местоположений неиспользуемых элементов.
- Удаление соответствующих строк.
- Сохранение изменений с возможным созданием резервной копии.

### Шаг 6: Генерация отчёта
- Составление списка удалённых элементов с указанием их местоположения.
- Сохранение отчёта в файл или вывод в консоль.

---

## 3. Алгоритм работы
1. **Инициализация:**
   - Чтение аргументов.
   - Проверка пути.
   - Создание структур данных для хранения информации о проекте.

2. **Сканирование файлов:**
   - Рекурсивный обход директорий.
   - Фильтрация по поддерживаемым языкам.

3. **Анализ каждого файла:**
   - Парсинг кода.
   - Построение графа зависимостей.

4. **Обработка графа:**
   - Определение всех используемых элементов.
   - Удаление узлов без входящих рёбер (неиспользуемые элементы).

5. **Очистка файлов:**
   - Поиск местоположений элементов в исходном коде.
   - Удаление строк или блоков.

6. **Отчёт:**
   - Составление итоговой информации.
   - Сохранение отчёта в файл.

---

## 4. План тестирования

### Юнит-тесты
- Проверка модулей отдельно (сканер, парсер, анализатор, очиститель).

### Интеграционные тесты
- Анализ небольших тестовых проектов с известной структурой.
- Проверка на наличие ошибок при обработке.

### Стресс-тесты
- Анализ крупных проектов с тысячами файлов.
- Измерение времени выполнения и корректности работы.

---

## 5. Будущие улучшения
- Расширение поддержки языков программирования.
- Внедрение GUI для удобства использования.
- Интеграция с системами контроля версий для автоматического коммитинга изменений.
